package com.br.song.example.rxreferences

import io.reactivex.Observable
import io.reactivex.functions.BiFunction
import io.reactivex.schedulers.Schedulers
import org.junit.Test
import java.util.concurrent.TimeUnit

/**
 * This call is for present some of most important operators in Rx framework.
 * Operators handle items produced for on specific Observable to be consumed to a specific Observer
 */
class RxOperators {

    /**
     * Map transform items generated by a specific Observable
     */
    @Test
    fun callForMap() {

        val fruits = listOf("Apple", "Pineapple", "Mellon", "Watermelon")

        Observable.fromArray(fruits)
            .map { it to it.size }
            .subscribe { pair ->
                val (name, length) = pair
                print("fruit: $name fruit array size: $length")
            }
    }

    private fun getMovies(actor: String) =
        Observable.create<String> { emitter ->
            emitter.onNext(
                when (actor) {
                    "Brad Pitt" -> "Fight Club"
                    "Tom Cruise" -> "Top Gun"
                    "Keanu Reeves" -> "John Wick"
                    else -> "No Movie matched"
                }
            )

            emitter.onComplete()
        }

    /**
     * Flatmap is similar to Map, the difference is that flatmap return a new Observable
     * not a modified one
     */
    @Test
    fun callForFlatmap() {

        val actors = listOf("Brad Pitt", "Tom Cruise", "Keanu Reeves")

        actors.forEach { item ->
            Observable.just(item)
                .flatMap { actor -> getMovies(actor) }
                .subscribe { print(it) }
        }
    }

    /**
     * the same says "filter" the array and return one or more items that satisfy the condition
     */
    @Test
    fun callForFilter() {
        Observable.fromArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
            .filter { item -> item % 2 == 0 }
            .subscribe { divisibleBy2 -> print("$divisibleBy2, ") }
    }

    /**
     * With zip you can use the Rx power. Combining a two or more Observables into one Observable
     * that can emit a final result
     */
    @Test
    fun callForZip() {

        Observable.zip(
            Observable.just("Joey", "Ross", "Chandler", "Monica", "Rachel", "Phoebe"),
            Observable.just("Barney", "Ted", "Marshall", "Lily", "Robin"),
            BiFunction<String, String, String>{
                    riend, himym -> "$riend = $himym\n"
            }
        ).subscribe { print(it)}
    }

    private fun getRandomDelay() = (Math.random() * 3).toLong() * 1000L

    private fun getAirportInitials() =
        Observable.create<String> { emitter ->
            listOf(
                "GRU", "MAO", "LAX", "MIA",
                "VCP", "SDU", "BEL", "REC"
            ).forEach {
                Thread.sleep(getRandomDelay())
                emitter.onNext(it)
            }
            emitter.onComplete()
        }.subscribeOn(Schedulers.newThread())

    private fun getBreakingBadActors() =
        Observable.create<String> { emitter ->
            listOf("Walt", "Jesse", "Skyler", "Saul", "Hank")
                .forEach {
                    Thread.sleep(getRandomDelay())
                    emitter.onNext(it)
                }
            emitter.onComplete()
        }.subscribeOn(Schedulers.newThread())


    /**
     * Just like concat an array, add item one by one in a defined sequence
     */
    @Test
    fun concat() {

        Observable.concat(
            getAirportInitials(),
            getBreakingBadActors()
        ).subscribe { result -> print("$result, ") }
    }

    /**
     * Merge with no order
     */
    @Test
    fun merge() {
        Observable.merge(
            getAirportInitials(),
            getBreakingBadActors()
        ).subscribe { result -> print("$result, ") }
    }

    private fun getDataFromCache() =
        Observable.create<String> {
            Thread.sleep(getRandomDelay())
            it.onNext("Cache")
            it.onComplete()
        }.subscribeOn(Schedulers.newThread())

    private fun getDataFromNetwork() =
        Observable.create<String> {
            Thread.sleep(getRandomDelay())
            it.onNext("Network")
            it.onComplete()
        }.subscribeOn(Schedulers.newThread())

    /**
     * Consume only the first N items emitted form a Observable
     */
    @Test
    fun take() {
        //Simple example
        Observable.fromArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
            .take(4)
            .subscribe { print("$it, ") }

        //Network example
        Observable.merge(getDataFromCache(), getDataFromNetwork())
            .take(1)
            .subscribe { print(it) }
    }

    /**
     * A Observable that emit only a value in a specific time range
     */
    @Test
    fun debounce() {
        Observable.create<Int> { emitter ->
            emitter.onNext(1)
            Thread.sleep(400) // 400 < 500, discarded
            emitter.onNext(2)
            Thread.sleep(600) // 600 > 500, emitted
            emitter.onNext(3)
            Thread.sleep(100) // 100 < 500, discarded
            emitter.onNext(4)
            Thread.sleep(600) // 600 > 500, emitted
            emitter.onNext(5)
            Thread.sleep(600) // 600 > 500, emitted
            emitter.onComplete()
        }
            .debounce(500, TimeUnit.MILLISECONDS)
            .subscribe { i -> println(i.toString()) }
    }

    /**
     * Observable that can emit a value multiple times
     */
    @Test
    fun repeat() {
        Observable.fromArray("Hello", "Rx", "World")
            .repeat(2)
            .subscribe { print(it) }
    }

    /**
     * if a Observable emit an error it is possible to try again (great for HTTP request calls)
     */
    @Test
    fun retry(){
        Observable.create<String> { emitter ->
            val number = (Math.random() * 10).toInt()
            if (number < 5) {
                emitter.onNext("Success!")
                emitter.onComplete()
            } else {
                emitter.onError(RuntimeException("Fail! try again"))
            }
        }.retry(2)
            .subscribe(
                { success -> println("Done! $success") },
                { println("Error") }
            )
    }

    /**
     * the same as Retry but you can pass a condition for it
     */
    @Test
    fun retryWhen() {
        Observable.create<String> { emitter ->
            val number = (Math.random() * 10).toInt()
            if (number < 5) {
                emitter.onNext("Success!")
                emitter.onComplete()
            } else {
                emitter.onError(RuntimeException("Fail! try again"))
            }
        }.retryWhen { completed ->
            completed.delay(2, TimeUnit.SECONDS)
        }.subscribe(
            { success -> println("Done! $success") },
            { println("Error") }
        )
    }
}

